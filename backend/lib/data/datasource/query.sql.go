// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package datasource

import (
	"context"
	"database/sql"
)

const getAllAudiobooks = `-- name: GetAllAudiobooks :many
Select id, title, author, narrator, description, duration, dir_path, chapter_count, genre
From Audiobook a
`

func (q *Queries) GetAllAudiobooks(ctx context.Context) ([]Audiobook, error) {
	rows, err := q.db.QueryContext(ctx, getAllAudiobooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Audiobook
	for rows.Next() {
		var i Audiobook
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Narrator,
			&i.Description,
			&i.Duration,
			&i.DirPath,
			&i.ChapterCount,
			&i.Genre,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAudiobookById = `-- name: GetAudiobookById :many
Select a.id, a.title, a.author, a.narrator, a.description, a.duration, a.dir_path, a.chapter_count, a.genre, c.id, c.audiobook_id, c.numbering, c.title, c.start_time, c.end_time, c.file_path
From Audiobook a
Join Chapter c On a.id = c.audiobook_id
Where a.id = ?
`

type GetAudiobookByIdRow struct {
	Audiobook Audiobook
	Chapter   Chapter
}

func (q *Queries) GetAudiobookById(ctx context.Context, id int64) ([]GetAudiobookByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getAudiobookById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAudiobookByIdRow
	for rows.Next() {
		var i GetAudiobookByIdRow
		if err := rows.Scan(
			&i.Audiobook.ID,
			&i.Audiobook.Title,
			&i.Audiobook.Author,
			&i.Audiobook.Narrator,
			&i.Audiobook.Description,
			&i.Audiobook.Duration,
			&i.Audiobook.DirPath,
			&i.Audiobook.ChapterCount,
			&i.Audiobook.Genre,
			&i.Chapter.ID,
			&i.Chapter.AudiobookID,
			&i.Chapter.Numbering,
			&i.Chapter.Title,
			&i.Chapter.StartTime,
			&i.Chapter.EndTime,
			&i.Chapter.FilePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAudiobookChapters = `-- name: GetAudiobookChapters :many
Select id, audiobook_id, numbering, title, start_time, end_time, file_path
From Chapter c
Where c.audiobook_id = ?
Order By numbering Asc
`

func (q *Queries) GetAudiobookChapters(ctx context.Context, audiobookID int64) ([]Chapter, error) {
	rows, err := q.db.QueryContext(ctx, getAudiobookChapters, audiobookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chapter
	for rows.Next() {
		var i Chapter
		if err := rows.Scan(
			&i.ID,
			&i.AudiobookID,
			&i.Numbering,
			&i.Title,
			&i.StartTime,
			&i.EndTime,
			&i.FilePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAudiobook = `-- name: InsertAudiobook :execresult
Insert Into Audiobook (title, author, narrator, description, duration, dir_path, chapter_count, genre) Values (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertAudiobookParams struct {
	Title        string
	Author       string
	Narrator     string
	Description  string
	Duration     int64
	DirPath      string
	ChapterCount int64
	Genre        string
}

func (q *Queries) InsertAudiobook(ctx context.Context, arg InsertAudiobookParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertAudiobook,
		arg.Title,
		arg.Author,
		arg.Narrator,
		arg.Description,
		arg.Duration,
		arg.DirPath,
		arg.ChapterCount,
		arg.Genre,
	)
}

const insertChapter = `-- name: InsertChapter :exec
Insert Into Chapter (audiobook_id, title, numbering, start_time, end_time, file_path) Values (?, ?, ?, ?, ?, ?)
`

type InsertChapterParams struct {
	AudiobookID int64
	Title       string
	Numbering   int64
	StartTime   float64
	EndTime     float64
	FilePath    string
}

func (q *Queries) InsertChapter(ctx context.Context, arg InsertChapterParams) error {
	_, err := q.db.ExecContext(ctx, insertChapter,
		arg.AudiobookID,
		arg.Title,
		arg.Numbering,
		arg.StartTime,
		arg.EndTime,
		arg.FilePath,
	)
	return err
}
